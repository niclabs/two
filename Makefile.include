# Makefile.include is heavily  based on
#
# boilermake: A reusable, but flexible, boilerplate Makefile.
# Copyright 2008, 2009, 2010 Dan Moulding, Alan T. DeKok
# Source: https://github.com/dmoulding/boilermake

# Note: Parameterized "functions" in this makefile that are marked with
#       "USE WITH EVAL" are only useful in conjuction with eval. This is
#       because those functions result in a block of Makefile syntax that must
#       be evaluated after expansion. Since they must be used with eval, most
#       instances of "$" within them need to be escaped with a second "$" to
#       accomodate the double expansion that occurs when eval is invoked.

# Only include this file once
ifndef _MAKEFILE_INCLUDE
_MAKEFILE_INCLUDE := 1

# Shell used in this makefile
# bash is used for 'echo -en'
SHELL = /bin/bash

# Get 'Makefile.include' directory, is the starting directory for evaluation
BASEDIR := $(dir $(lastword $(MAKEFILE_LIST)))
BASEDIR := $(patsubst ${CURDIR}/%,./%,$(BASEDIR))
BASEDIR := $(BASEDIR:%/=%)

### Configurable build flags for all targets
CF_ALL ?= -std=c99 -Wall -Wextra
LD_ALL ?=
LL_ALL ?=

### Configurable build tools
CC 		 ?= gcc
COMPILE  = $(CC) $(CF_ALL) $(CFLAGS) -MP -MMD -o $@ -c $<
LINK 	 = $(CC) $(LF_ALL) $(LDFLAGS) -o $@ $^ $(LL_ALL) $(LDLIBS)
ARCHIVE  = $(AR) $(ARFLAGS) $@ $^

# Quiet option, to output compile and link commands
QUIET ?= 1

# CANONICAL_PATH - Given one or more paths, converts the paths to the canonical
#   form. The canonical form is the path, relative to the project's top-level
#   directory (the directory from which "make" is run), and without
#   any "./" or "../" sequences. For paths that are not  located below the
#   top-level directory, the canonical form is the absolute path (i.e. from
#   the root of the filesystem) also without "./" or "../" sequences.
define CANONICAL_PATH
$(patsubst ${CURDIR}/%,%,$(abspath ${1}))
endef

# QUALIFY_PATH - Given a "root" directory and one or more paths, qualifies the
#   paths using the "root" directory (i.e. appends the root directory name to
#   the paths) except for paths that are absolute.
define QUALIFY_PATH
$(addprefix ${1}/,$(filter-out /%,${2}))$(filter /%,${2})
endef

# PEEK - Parameterized "function" that results in the value at the top of the
#   specified colon-delimited stack.
define PEEK
$(lastword $(subst :, ,${1}))
endef

# POP - Parameterized "function" that pops the top value off of the specified
#   colon-delimited stack, and results in the new value of the stack. Note that
#   the popped value cannot be obtained using this function; use peek for that.
define POP
${1:%:$(lastword $(subst :, ,${1}))=%}
endef

# PUSH - Parameterized "function" that pushes a value onto the specified colon-
#   delimited stack, and results in the new value of the stack.
define PUSH
${2:%=${1}:%}
endef

define INCLUDE_SUBDIR
    # Include submakefile if it exists
    ifneq "$$(wildcard ${1}/Makefile)" ""
        $$(eval $$(call INCLUDE_SUBMAKEFILE,${1}/Makefile))
    endif
endef

# Include subdirectory makefile if it exists
define INCLUDE_SUBMAKEFILE
    # Reset makefile variables
    TARGET       :=
    SOURCES      :=
    SUBDIRS      :=
    CFLAGS       :=
    LDFLAGS      :=
    LDLIBS       :=

    # A directory stack is maintained so that the correct paths are used as we
    # recursively include all submakefiles. Get the makefile's directory and
    # push it onto the stack.
    DIR := $(call CANONICAL_PATH,$(dir ${1}))
    DIR_STACK := $$(call PUSH,$${DIR_STACK},$${DIR})

    # Update CURDIR for included submakefile
    CWD := $${CURDIR}
    CURDIR := $$(call QUALIFY_PATH,$${CURDIR},$${DIR})
    include ${1}
    CURDIR := $${CWD}

    # Initialize internal local variables
    OBJS :=

    # Ensure that a valid value is set for BUILD_DIR, TARGET_DIR, IS_PHONY
    ifeq "$$(strip $${BUILD_DIR})" ""
        BUILD_DIR := $${BASEDIR}/build
    endif
    ifeq "$$(strip $${TARGET_DIR})" ""
        TARGET_DIR := $${BASEDIR}
    endif

    # Quiet flag
    ifeq ($$(QUIET),1)
        TRACE_CC = @echo "  CC       " $$<
        TRACE_LD = @echo "  LD       " $$@
        TRACE_AR = @echo "  AR       " $$@
        TRACE_RM = @echo "  RM       " $$(sort $$(addprefix *,$$(suffix $$(BUILD_FILES))))
        Q=@
        MAKEFLAGS += --no-print-directory
    else
        TRACE_CC =
        TRACE_LD =
        TRACE_AR =
        TRACE_RM =
        Q=
    endif

    # Determine which target this makefile's variables apply to. A stack is
    # used to keep track of which target is the "current" target as we
    # recursively include other submakefiles.
    ifneq "$$(strip $${TARGET})" ""
        # makefile apply to this new target. Initialize the target's variables.
        TGT := $$(strip $${TARGET})

        # Check for phony target
        ifeq "$$(suffix $${TGT})" ".PHONY"
            TGT := $$(basename $${TGT})
            $${TGT}_IS_PHONY := 1
        endif

        TARGETS         += $${TGT}
        $${TGT}_CFLAGS  := $${CFLAGS}
        $${TGT}_LDFLAGS := $${LDFLAGS}
        $${TGT}_LDLIBS  := $${LDLIBS}
        $${TGT}_OBJDIR  := $${BUILD_DIR}/$$(call CANONICAL_PATH,$${TGT})
        $${TGT}_OBJS    :=
        $${TGT}_INCDIRS :=
        $${TGT}_DEPS    :=
        $${TGT}_SOURCES :=
    else
        # The values defined by this makefile apply to the the "current" target
        # as determined by which target is at the top of the stack.
        TGT := $$(strip $$(call PEEK,$${TGT_STACK}))
        $${TGT}_CFLAGS  += $${CFLAGS}
        $${TGT}_LDFLAGS += $${LDFLAGS}
        $${TGT}_LDLIBS  += $${LDLIBS}
    endif

    # Push the current target onto the target stack.
    TGT_STACK := $$(call PUSH,$${TGT_STACK},$${TGT})

    ifneq "$$(strip $${SOURCES})" ""
         # Qualify and canonicalize paths.
         SOURCES     := $$(call QUALIFY_PATH,$${DIR},$${SOURCES})
         SOURCES     := $$(call CANONICAL_PATH,$${SOURCES})

         # Convert the source file names to their corresponding object file
         # names.
         OBJS := $$(addprefix $${$${TGT}_OBJDIR}/,\
                    $$(addsuffix .o,$$(basename $${SOURCES})))

         $${TGT}_SOURCES += $${SOURCES}
         $${TGT}_OBJS    += $${OBJS}
         $${TGT}_DEPS    += $${OBJS:%.o=%.d}
         $${TGT}_INCDIRS += $$(sort $$(dir $${SOURCES}))

         BUILD_FILES     += $${$${TGT}_OBJS} $${$${TGT}_DEPS}
    endif

    ifneq "$$(strip $${SUBDIRS})" ""
         # This makefile has submakefiles. Recursively include them.
         $$(foreach D,$${SUBDIRS},\
              $$(eval $$(call INCLUDE_SUBDIR,\
                         $$(call CANONICAL_PATH,\
                            $$(call QUALIFY_PATH,$${DIR},$${D})))))
    endif

    # Reset the "current" target to it's previous value.
    TGT_STACK := $$(call POP,$${TGT_STACK})
    TGT := $$(call PEEK,$${TGT_STACK})

    # Reset the "current" directory to it's previous value.
    DIR_STACK := $$(call POP,$${DIR_STACK})
    DIR := $$(call PEEK,$${DIR_STACK})
endef

define FINALIZE_DEPENDENCY
cp $(@:.o=.d) $(@:.o=.$$$$); \
sed -e 's/#.*//' -e 's/^[^:]*: *//' -e 's/ *\\$$//' \
    -e '/^$$/ d' -e 's/$$/ :/' < $(@:.o=.$$$$) >> $(@:.o=.d); \
rm -f $(@:.o=.$$$$)
endef

define ADD_TARGET_RULES
    # Add build object rules
    $${${1}_OBJS}: CFLAGS += $${${1}_CFLAGS} $$(addprefix -I,$${${1}_INCDIRS})

    # Add rule to compile individual objects
    $${${1}_OBJDIR}/%.o: %.c
    $${${1}_OBJDIR}/%.o: %.c $${${1}_OBJDIR}/%.d
		@mkdir -p $$(dir $$@)
		$$(TRACE_CC)
		$$(Q)$$(strip $${COMPILE})
		@$${FINALIZE_DEPENDENCY}

    # Add header dependency targets
    $${${1}_DEPS}:
    include $$(wildcard $${${1}_DEPS})

    ifeq "$${${1}_IS_PHONY}" ""
        # Build the actual target
        ifeq "$$(suffix ${1})" ".a"
            # If target is an archive file
            $${TARGET_DIR}/${1}: $${${1}_OBJS}
        else
            # Target is an executable
            $${TARGET_DIR}/${1}: LDFLAGS += $${${1}_LDFLAGS}
            $${TARGET_DIR}/${1}: LDLIBS += $${${1}_LDLIBS}
            $${TARGET_DIR}/${1}: $${${1}_OBJS}
				@mkdir -p $$(dir $$@)
				$$(TRACE_LD)
				$$(Q)$$(strip $$(LINK))
        endif
    else
        .PHONY: ${1}
    endif
endef

# Remove implicit rules
.SUFFIXES:
.SUFFIXES: .c .o

# Define general variables
DIR_STACK     :=
TGT_STACK     :=
TARGETS       :=
BUILD_FILES   :=
BUILD_TARGETS :=

.DEFAULT_GOAL := all

# Include top-level Makefile
$(eval $(call INCLUDE_SUBMAKEFILE,Makefile))

# Add non-phony targets to build file
BUILD_TARGETS += $(foreach TGT,${TARGETS},$(if ${${TGT}_IS_PHONY},,${TARGET_DIR}/${TGT}))

# Add non-phony targets
.PHONY: all
all: $(foreach TGT,${TARGETS},$(if ${${TGT}_IS_PHONY},,${TARGET_DIR}/${TGT}))

.PHONY: debug
debug: CF_ALL += -g
debug: all

# Add target rules
$(foreach TGT,${TARGETS},\
	$(eval $(call ADD_TARGET_RULES,${TGT})))

# General directory independent rules
${TARGET_DIR}/%.a:
	@mkdir -p $(dir $@)
	$(TRACE_AR)
	$(Q)$(strip $(ARCHIVE))

.PHONY:	clean
clean:
	$(TRACE_RM)
	$(Q)$(strip rm -f $(wildcard $(BUILD_FILES)))

distclean:
	@echo "Removing build targets"
	$(Q)$(strip rm -f $(wildcard $(BUILD_TARGETS)))
	$(Q)rm -rf $(BUILD_DIR)

# Prevent make from removing any build targets, including intermediate ones
.SECONDARY:	$(BUILD_FILES)


endif
